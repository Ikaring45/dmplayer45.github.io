<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, viewport-fit=cover">
  <title>DmPlayer v2.0.16</title> <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="DmPlayer">
  
  <link rel="manifest" href="./manifest.json">

  <script src="https://cdn.jsdelivr.net/npm/jsmediatags@3.9.7/dist/jsmediatags.min.js"></script>

  <style>
    /* -------------------- */
    /* ã‚¹ã‚¿ã‚¤ãƒ«ã‚·ãƒ¼ãƒˆ */
    /* -------------------- */
    * { box-sizing: border-box; }
    :root {
      --dark-bg: #121212;
      --medium-bg: #181818;
      --accent-color: #00e6b8;
      --text-color: #ffffff;
      --text-light: #b3b3b3;
      --border-color: #333333;
      --error-color: #e6005c; 
      --debug-color: #00b300; 
      --switch-off: #4a4a4a;
      --switch-on: var(--accent-color);
      --peak-hold-color: #ffcc00;
    }

    body {
      margin: 0;
      background-color: var(--dark-bg); 
      font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      color: var(--text-color);
      height: 100vh;
      min-height: -webkit-fill-available;
      overflow: hidden; 
      display: flex; 
    }
    
    .sidebar {
      width: 250px; 
      flex-shrink: 0; 
      background-color: var(--medium-bg);
      border-right: 1px solid var(--border-color);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      padding: 0;
      position: relative; 
      height: 100%; 
    }

    /* ğŸ”§ ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ãƒ¢ãƒ¼ãƒ‰æ™‚ã€ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’æœ€å‰é¢ã«ã—ã¦ UI ã‚’é€éã•ã›ã‚‹ */
body.visualizer-mode #visualizerCanvas {
    z-index: 50 !important;   /* ã™ã¹ã¦ã® UI ã®æ‰‹å‰ã¸ç§»å‹• */
    opacity: 1.0 !important;
}

/* UI ã‚’è–„ãã—ã¦ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ã‚’éš ã•ãªã„ã‚ˆã†ã«ã™ã‚‹ */
body.visualizer-mode .screen > *:not(#visualizerCanvas) {
    position: relative;
    z-index: 1 !important;   /* ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚ˆã‚Šä¸‹ã«é…ç½® */
    opacity: 0.35;           /* é€éï¼ˆå¿…è¦ã§ã‚ã‚Œã° 0ã€œ1 ã§èª¿æ•´å¯èƒ½ï¼‰ */
}

    
    .sidebar-content {
        flex-grow: 1;
        overflow-y: auto;
        padding: 15px 15px 5px 15px;
    }

    .sidebar h2 {
      font-size: 1.1em;
      margin-bottom: 10px;
      color: var(--text-light);
    }
    
    .sidebar-footer {
        padding: 10px 15px 15px 15px;
        background-color: #242424; 
        border-top: 1px solid #444444; 
        flex-shrink: 0; 
    }

    .app-info {
        font-size: 0.9em;
        color: var(--text-light);
        margin-bottom: 10px;
        display: flex;
        justify-content: space-between;
    }

    #appName {
        font-weight: bold;
        color: var(--text-color);
    }

    #appVersion {
        font-size: 0.8em;
        color: #999999;
        padding-top: 1px;
    }

    .footer-btn {
        width: 100%;
        padding: 8px;
        margin-top: 5px;
        background-color: #383838;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
        font-size: 0.9em;
        text-align: center;
        -webkit-tap-highlight-color: transparent;
    }

    .footer-btn:hover {
        background-color: #4a4a4a;
    }
    
    .input-group {
        margin-bottom: 15px;
    }
    .input-group label {
        display: block;
        font-size: 0.9em;
        color: var(--text-light);
        margin-bottom: 5px;
    }
    .input-group input[type="text"] {
        width: 100%;
        padding: 8px;
        background-color: #383838;
        border: 1px solid #555555;
        color: var(--text-color);
        border-radius: 4px;
        font-size: 1em;
    }

    .main {
      flex: 1; 
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative; 
      height: 100%; 
    }
    
    #fileInput { display: none; }
    
    .file-label {
        display: block;
        width: 100%;
        padding: 10px 15px;
        background-color: var(--accent-color); 
        color: var(--dark-bg);
        border-radius: 6px;
        font-weight: bold;
        text-align: center;
        cursor: pointer;
        transition: background-color 0.2s, box-shadow 0.2s;
        font-size: 1em;
        box-shadow: 0 4px 10px rgba(0, 230, 184, 0.3);
        margin-bottom: 15px; 
        margin-top: 5px; 
    }
    
    .file-label:hover {
        background-color: #00b38c;
        box-shadow: 0 6px 12px rgba(0, 230, 184, 0.4);
    }
    
    .switch-container {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 15px;
        padding: 5px 0;
        font-size: 0.95em;
    }

    .switch {
        position: relative;
        display: inline-block;
        width: 45px;
        height: 25px;
    }

    .switch input { opacity: 0; width: 0; height: 0; }

    .slider {
        position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
        background-color: var(--switch-off); transition: .4s; border-radius: 25px;
    }

    .slider:before {
        position: absolute; content: ""; height: 17px; width: 17px; left: 4px; bottom: 4px;
        background-color: white; transition: .4s; border-radius: 50%;
    }

    input:checked + .slider { background-color: var(--switch-on); }
    input:checked + .slider:before { transform: translateX(20px); }

    .audio-list {
        display: flex; flex-direction: column; gap: 5px; padding-top: 5px;
    }

    .queue-item {
        display: flex; align-items: center; width: 100%; padding: 8px 10px;
        background-color: #242424; color: var(--text-color); border: 1px solid #3a3a3a;
        border-radius: 6px; cursor: pointer; transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
        text-align: left; font-size: 0.9em; position: relative; overflow: hidden;
        -webkit-tap-highlight-color: transparent;
    }

    .queue-item:hover { background-color: #303030; }

    .queue-item.active-track {
        border: 1px solid var(--accent-color); border-left: 4px solid var(--accent-color); 
        background-color: #1a1a1a; box-shadow: 0 0 8px rgba(0, 230, 184, 0.3); 
        padding-left: 10px; 
    }
    
    .queue-item.placeholder-track { opacity: 0.6; font-style: italic; }
    
    .queue-index {
        font-size: 1.1em; font-weight: bold; color: var(--text-light);
        width: 25px; flex-shrink: 0; margin-right: 8px; text-align: center;
    }
    
    .track-info-container {
        flex-grow: 1; min-width: 0; display: flex; flex-direction: column;
    }

    .track-title-display {
        font-weight: bold; color: var(--text-color); white-space: nowrap;
        overflow: hidden; text-overflow: ellipsis; 
    }

    .track-artist-display {
        font-size: 0.8em; color: var(--text-light); white-space: nowrap;
        overflow: hidden; text-overflow: ellipsis; 
    }
    
    .queue-controls {
        flex-shrink: 0; margin-left: 8px; display: flex; align-items: center; gap: 3px; 
    }

    .queue-control-btn {
        background: #3a3a3a; color: white; border: none; padding: 4px;
        border-radius: 3px; cursor: pointer; font-size: 0.65em; line-height: 1;
        height: 20px; width: 20px; display: flex; align-items: center;
        justify-content: center; transition: background-color 0.1s, transform 0.1s;
    }
    
    .queue-control-btn:disabled {
        opacity: 0.4;
        cursor: default;
        transform: none;
        background: #3a3a3a;
        color: white;
    }

    .queue-control-btn:hover:not(:disabled) {
        background: var(--accent-color); color: var(--dark-bg); transform: scale(1.1);
    }
    
    .playing-status {
        font-size: 1.2em; color: var(--accent-color); width: 20px; text-align: center; line-height: 1;
    }
    .playing-status.ready-to-play { color: var(--error-color); }
    
    .screen {
      flex: 1; 
      padding: 30px;
      padding-top: 50px; 
      background: linear-gradient(135deg, var(--medium-bg), var(--dark-bg));
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      overflow-y: auto; 
      position: relative; 
      perspective: 1000px; 
      z-index: 1; 
    }

    #visualizerCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0; 
        opacity: 0.6; 
        pointer-events: none; 
    }

    .cover-art-container {
      width: 250px; 
      height: 250px;
      margin-bottom: 25px;
      text-align: center;
      position: relative;
      transform-style: preserve-3d; 
      transition: transform 0.6s; 
      cursor: pointer; 
    }
    
    .cover-art-face {
        position: absolute; width: 100%; height: 100%;
        backface-visibility: hidden; border-radius: 12px;
        box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5), 0 0 0 5px var(--medium-bg);
        overflow: hidden; background-color: var(--medium-bg); padding: 0;
    }

    .cover-art-front { z-index: 2; transform: rotateY(0deg); }

    #coverArt {
      width: 100%; height: 100%; object-fit: cover; border-radius: 12px;
    }
    
    .cover-art-back {
        transform: rotateY(180deg); z-index: 1; display: flex;
        justify-content: center; align-items: flex-start;
        background-color: #1c1c1c; border: 3px solid var(--accent-color); 
    }

    .cover-art-container.flipped { transform: rotateY(180deg); }

    #lyricsDisplay {
        padding: 15px; color: var(--text-light); font-size: 0.85em;
        text-align: center; overflow-y: auto; white-space: pre-wrap;
        max-height: 100%; width: 100%; line-height: 1.4;
    }

    #trackTitle {
      font-size: 2em; font-weight: bold; margin-top: 10px;
    }

    #trackArtist {
        font-size: 1.2em; color: var(--text-light); margin-bottom: 10px; 
    }
    
    .mode-status-display {
        display: flex; gap: 20px; margin-bottom: 30px; font-size: 1.0em; font-weight: 500;
    }

    .mode-item {
        display: flex; align-items: center; gap: 8px; padding: 5px 10px;
        border-radius: 4px; background-color: var(--medium-bg);
        color: var(--text-light); border: 1px solid var(--border-color);
        transition: all 0.2s;
    }

    .mode-item.active {
        background-color: var(--accent-color); color: var(--dark-bg);
        border-color: var(--accent-color); font-weight: bold;
        box-shadow: 0 4px 8px rgba(0, 230, 184, 0.2);
    }

    .mode-icon { font-size: 1.2em; line-height: 1; }

    .seek-container {
      width: 90%; max-width: 600px; margin-top: 30px; display: flex; align-items: center;
    }

    #seekBar {
      flex-grow: 1; margin: 0 15px; -webkit-appearance: none; appearance: none; 
      height: 8px; background: transparent; border-radius: 4px;
      cursor: pointer; transition: background 0.3s;
      --progress: 0%; 
    }

    #seekBar::-webkit-slider-runnable-track {
      width: 100%; height: 8px; cursor: pointer; border-radius: 4px;
      background: linear-gradient(to right, 
        var(--accent-color) 0%, var(--accent-color) var(--progress), 
        var(--border-color) var(--progress), var(--border-color) 100%
      );
    }
    
    #seekBar::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 1px; height: 1px; opacity: 0; border-radius: 50%; background: var(--accent-color); cursor: pointer; margin-top: -4px; }
    #volumeSlider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; border-radius: 50%; background: var(--accent-color); cursor: pointer; box-shadow: 0 0 5px var(--accent-color); }
    
    .time-display { font-size: 0.9em; width: 45px; text-align: center; color: var(--text-light); }

    .controls-moved {
        display: flex; align-items: center; justify-content: center;
        gap: 15px; margin-top: 20px; 
    }

    .controls-moved button {
        width: 45px; height: 45px; line-height: 45px; padding: 0;
        margin: 5px 0; background-color: var(--accent-color); border: none;
        font-size: 1.2em; color: var(--dark-bg); border-radius: 50%; 
        cursor: pointer; transition: transform 0.1s, background-color 0.2s, box-shadow 0.2s;
        font-weight: bold; -webkit-tap-highlight-color: transparent;
        display: flex; align-items: center; justify-content: center;
    }
    
    .controls-moved button:hover {
        background-color: #00b38c; transform: scale(1.1);
    }
    
    #playPauseBtn { width: 55px; height: 55px; font-size: 1.6em; }
    
    #seekBackwardBtn, #seekForwardBtn {
        background-color: var(--accent-color); color: var(--dark-bg); 
        font-size: 1.4em; width: 45px; height: 45px; border-radius: 50%;
        line-height: 1; font-weight: 900; padding-bottom: 2px; 
    }

    #seekBackwardBtn:hover, #seekForwardBtn:hover {
        background-color: #00b38c; transform: scale(1.1);
    }

    .player-ready #playPauseBtn {
        box-shadow: 0 0 0 4px var(--accent-color), 0 0 20px var(--accent-color);
        background-color: var(--accent-color); color: var(--dark-bg); 
    }

    #optionsBtn {
        position: absolute; top: 15px; left: 15px; background: none; 
        border: none; font-size: 1.8em; color: var(--text-color); 
        cursor: pointer; z-index: 50; padding: 5px 10px; 
        -webkit-tap-highlight-color: transparent; line-height: 1;
        transition: color 0.2s;
    }
    #optionsBtn:hover { color: var(--accent-color); }

    .control-panel {
      flex-shrink: 0; display: flex; background-color: var(--medium-bg);
      padding: 15px; flex-wrap: wrap; border-top: 1px solid var(--border-color);
      height: 180px; gap: 20px; justify-content: space-between;
    }
    
    .modes { flex: 1; padding: 0; min-width: 200px; }
    
    .volume-container {
        display: flex; align-items: center; gap: 8px; 
        padding-bottom: 5px; margin-top: 15px;
    }

    #volumeSlider {
        flex-grow: 1; margin: 0; -webkit-appearance: none; appearance: none; 
        height: 8px; background: #555; border-radius: 4px; cursor: pointer;
    }

    .section-title {
      font-size: 0.9em; margin-bottom: 5px; color: var(--text-light);
      border-bottom: 1px solid var(--border-color); padding-bottom: 5px;
    }
    
    .mixer-container {
        display: flex; align-items: center; gap: 10px; padding: 2px 0; 
        position: relative; 
    }

    .channel-label {
        font-size: 0.8em; color: var(--text-light); width: 15px; text-align: center;
    }

    .mixer-bar {
        flex-grow: 1; height: 8px; background-color: #3a3a3a; 
        border-radius: 6px; overflow: hidden; position: relative;
    }

    .mixer-bar-fill {
        height: 100%; width: 0%; transition: width 0.05s linear; 
        background-color: #008000; 
    }
    
    .peak-hold-indicator {
        position: absolute; top: 0; right: 0; width: 4px; height: 100%;
        background-color: var(--peak-hold-color); transition: transform 0.5s ease-out; 
        z-index: 10; border-radius: 2px;
    }
    
    .mode-buttons {
        display: flex; gap: 10px; margin-top: 10px;
    }
    .mode-buttons button {
        flex: 1; padding: 8px; background-color: #383838;
        color: white; border: none; border-radius: 4px;
        cursor: pointer; transition: background-color 0.2s;
        font-size: 0.9em;
    }
    .mode-buttons button:hover { background-color: #4a4a4a; }
    
    #notificationContainer {
        position: absolute; top: 15px; right: 15px; z-index: 1000;
        pointer-events: none; max-width: 300px; overflow: hidden;
    }
    
    .notification-message {
        background-color: #333; color: white; padding: 10px 15px;
        border-radius: 8px; margin-bottom: 10px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        opacity: 0; transform: translateX(100%); 
        transition: opacity 0.3s ease-out, transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        pointer-events: all; font-size: 0.9em;
        border-left: 4px solid var(--accent-color); white-space: pre-wrap;
    }

    .notification-message.show { opacity: 1; transform: translateX(0); }
    .notification-message.slide-out { opacity: 0; transform: translateX(100%); }
    .notification-message.error { background-color: #4a1d2e; border-left-color: var(--error-color); }
    .notification-message.debug { background-color: #1b4d24; border-left-color: var(--debug-color); font-size: 0.8em; opacity: 0.7; }

    .settings-overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background-color: var(--medium-bg); z-index: 10; padding: 15px;
        display: flex; flex-direction: column;
        transform: translateX(-100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .settings-overlay.show { transform: translateX(0); }
    
    .settings-content { flex-grow: 1; overflow-y: auto; }
    
    .settings-footer {
        padding-top: 15px; border-top: 1px solid var(--border-color); margin-top: auto;
    }
    
    .slider-container { margin-bottom: 20px; padding: 5px 0; }
    .slider-container label {
        display: block; font-size: 0.95em; margin-bottom: 5px; color: var(--text-light);
    }
    .slider-container input[type="range"] {
        width: 100%; -webkit-appearance: none; appearance: none; height: 8px;
        background: #555; border-radius: 4px; cursor: pointer;
    }
    .slider-value {
        font-size: 0.85em; color: var(--accent-color); display: block;
        text-align: right; margin-top: 5px;
    }

    .track-details-overlay {
        position: absolute; top: 0; right: 0; width: 300px; height: 100%;
        background-color: #242424; z-index: 200; padding: 20px;
        display: flex; flex-direction: column;
        transform: translateX(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border-left: 1px solid #444444;
    }
    
    .track-details-overlay.show { transform: translateX(0); }

    .details-content {
        flex-grow: 1; overflow-y: auto; padding-top: 10px;
        font-size: 0.9em; color: var(--text-light);
    }
    
    .details-content strong {
        color: var(--text-color); font-weight: bold; display: block; padding-top: 5px;
    }

    .details-actions { display: flex; gap: 10px; padding: 10px 0; }
    .details-actions button {
        flex: 1; padding: 8px; background-color: #3a3a3a; color: white;
        border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s;
    }
    .details-actions button:hover { background-color: #4a4a4a; }

    .close-details-btn {
        margin-top: auto; padding: 10px; background-color: var(--accent-color);
        color: var(--dark-bg); border: none; border-radius: 4px;
        cursor: pointer; font-weight: bold; transition: background-color 0.2s;
    }
    .close-details-btn:hover { background-color: #00b38c; }
    
    #metadataEditForm {
        padding: 10px; border: 1px dashed var(--border-color);
        border-radius: 8px; margin-top: 15px; display: none;
    }
    #metadataEditForm.show { display: block; }

    #player { display: none; }
    
    /* â­ ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ãƒ¢ãƒ¼ãƒ‰ (v2.0.16) â­ */
    body.visualizer-mode {
        display: block; 
    }
    
    /* ã‚µã‚¤ãƒ‰ãƒãƒ¼ï¼ˆã‚­ãƒ¥ãƒ¼ï¼‰ã¯è¡¨ç¤ºã™ã‚‹ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã‚­ãƒ¥ãƒ¼ã‚’è¦‹ãŸã„ã¨ã®è¦æœ›ãŒã‚ã‚‹ãŸã‚å¸¸ã«è¡¨ç¤º */
    body.visualizer-mode .sidebar {
        display: block !important;
        z-index: 3;
    }

    /* ãƒ¡ã‚¤ãƒ³é ˜åŸŸã¯ã‚µã‚¤ãƒ‰ãƒãƒ¼åˆ†ã‚’æ®‹ã—ã¦è¡¨ç¤º */
    body.visualizer-mode .main {
        width: calc(100% - 250px);
        height: 100vh;
        flex: 1;
    }
    
    /* control-panel ã¯è¡¨ç¤ºã—ã¦ãŠãï¼ˆãƒœãƒªãƒ¥ãƒ¼ãƒ /ã‚·ãƒ£ãƒƒãƒ•ãƒ«ç­‰ã‚’æ®‹ã™ï¼‰ */
    body.visualizer-mode .control-panel {
        display: flex !important;
        z-index: 2;
    }
    
    body.visualizer-mode .screen {
        padding: 0; 
    }
    
    /* ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€Œãƒœã‚¿ãƒ³é¡ã®ã¿ã€ã‚’éè¡¨ç¤ºã«ã—ã¦
       ã‚¢ãƒ«ãƒãƒ ã‚«ãƒãƒ¼ã‚„ã‚·ãƒ¼ã‚¯ãƒãƒ¼ã€ã‚¿ã‚¤ãƒˆãƒ«é¡ã¯è¡¨ç¤ºã—ãŸã¾ã¾ã«ã™ã‚‹ã€‚
       canvas ã¯èƒŒæ™¯ã¨ã—ã¦è¡¨ç¤ºã•ã‚Œã€UI ã¯ãã®ä¸Šã«é‡ãªã‚‹ã€‚ */
    /* éè¡¨ç¤º: ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼è¡¨ç¤ºæ™‚ã¯ã‚¢ãƒ«ãƒãƒ ã‚«ãƒãƒ¼ï¼ã‚¿ã‚¤ãƒˆãƒ«ï¼ã‚·ãƒ¼ã‚¯ãƒãƒ¼ã‚’éš ã™ */
    body.visualizer-mode .cover-art-container,
    body.visualizer-mode #trackTitle,
    body.visualizer-mode #trackArtist,
    body.visualizer-mode .seek-container,
    body.visualizer-mode .cover-art-face {
        display: none !important;
    }

    /* éè¡¨ç¤º: ç”»é¢ä¸Šã®å†ç”Ÿ/å‰å¾Œãªã©ã®å¤§ããªã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã¯éš ã™ï¼ˆæ“ä½œã¯ control-panel ã§å¯èƒ½ï¼‰ */
    body.visualizer-mode .controls-moved,
    body.visualizer-mode #optionsBtn {
        display: none !important;
    }
    
    /* éšœå®³ã«ãªã‚‹æµ®éŠè¡¨ç¤ºï¼ˆãƒ«ãƒ¼ãƒ—/ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼‰ã‚’éè¡¨ç¤ºã«ã™ã‚‹ */
    body.visualizer-mode #loopStatus,
    body.visualizer-mode #shuffleStatus {
        display: none !important;
    }
    
    /* ã‚­ãƒ£ãƒ³ãƒã‚¹ã¨é€šçŸ¥ã€ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã¯è¡¨ç¤ºã‚’ç¶­æŒ */
    body.visualizer-mode #visualizerCanvas {
        display: block !important; 
        opacity: 1.0; 
        z-index: 0 !important;
        pointer-events: none !important;
    }

    body.visualizer-mode #notificationContainer {
        display: block !important;
        pointer-events: none;
    }

    /* è¨­å®šã‚„è©³ç´°ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã¯è¡¨ç¤ºã‚’ç¶­æŒ */
    body.visualizer-mode .settings-overlay.show,
    body.visualizer-mode .track-details-overlay.show {
        display: flex !important; 
        z-index: 100;
    }

  </style>
</head>
<body>

  <div class="sidebar">
    
    <div id="settingsOverlay" class="settings-overlay">
        <h2>âš™ï¸ è¨­å®šãƒ¡ãƒ‹ãƒ¥ãƒ¼</h2>
        <div class="settings-content">
            
            <div class="switch-container">
                <label for="visualizerToggle">ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼</label>
                <label class="switch">
                    <input type="checkbox" id="visualizerToggle">
                    <span class="slider"></span>
                </label>
            </div>
            
            <div class="switch-container">
                <label for="nextTrackNotificationToggle">æ¬¡ã®æ›²ã‚’é€šçŸ¥</label>
                <label class="switch">
                    <input type="checkbox" id="nextTrackNotificationToggle" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <div class="switch-container">
                <label for="debugToggle">ãƒ‡ãƒãƒƒã‚°è¡¨ç¤º</label>
                <label class="switch">
                    <input type="checkbox" id="debugToggle">
                    <span class="slider"></span>
                </label>
            </div>
            
            <div class="slider-container">
                <label for="crossfadeDurationSlider">ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰æ™‚é–“ (<span id="crossfadeValue">1.5</span>ç§’)</label>
                <input type="range" id="crossfadeDurationSlider" min="0.0" max="5.0" step="0.1" value="1.5">
                <span class="slider-value">æ›²ã®åˆ‡ã‚Šæ›¿ãˆã‚’æ»‘ã‚‰ã‹ã«ã—ã¾ã™ã€‚</span>
            </div>
            
        </div>
        <div class="settings-footer">
            <button id="closeSettingsBtn" class="footer-btn">é–‰ã˜ã‚‹</button>
        </div>
    </div>
    
    <div class="sidebar-content">
      <h2>ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ </h2>
      <input type="file" id="fileInput" accept="audio/mp3, audio/m4a, audio/flac, audio/ogg, audio/wav, audio/mp4" multiple />
      <label for="fileInput" class="file-label">ğŸ“‚ ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</label>
      
      <h2>ã‚­ãƒ¥ãƒ¼</h2>
      <div class="audio-list" id="audioList"></div>
    </div>

    <div class="sidebar-footer">
        <div class="app-info">
          <div id="appName">DmPlayer</div>
          <div id="appVersion">v2.0.16</div> </div>
        <button id="settingsBtn" class="footer-btn">âš™ï¸ è¨­å®š</button>
        <button id="helpBtn" class="footer-btn">ğŸ’¡ ãƒ˜ãƒ«ãƒ—</button>
    </div>
  </div>

  <div class="main">
    
    <div id="notificationContainer"></div>
    <div id="trackDetailsOverlay" class="track-details-overlay">
        <h2>â„¹ï¸ ãƒˆãƒ©ãƒƒã‚¯è©³ç´°</h2>
        <div id="currentTrackInfoDetails" class="details-content">
            è©³ç´°ã‚’èª­ã¿è¾¼ã¿ä¸­...
            <div id="metadataEditForm">
                <div class="input-group">
                    <label for="editTitle">ã‚¿ã‚¤ãƒˆãƒ«</label>
                    <input type="text" id="editTitle">
                </div>
                <div class="input-group">
                    <label for="editArtist">ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆ</label>
                    <input type="text" id="editArtist">
                </div>
                <button class="footer-btn" id="saveMetadataBtn">ã‚¿ã‚°ã‚’ä¿å­˜ã—ã¦é©ç”¨</button>
            </div>
        </div>
        
        <div class="details-actions">
            <button id="toggleEditBtn">ã‚¿ã‚°ã‚’ç·¨é›†</button>
        </div>
        <button id="closeDetailsBtn" class="close-details-btn">é–‰ã˜ã‚‹</button>
    </div>
    
    <div class="screen" id="playerScreen">
      
      <canvas id="visualizerCanvas"></canvas> 

      <button id="optionsBtn" title="ãƒˆãƒ©ãƒƒã‚¯è©³ç´°">â‹®</button>
      
      <div class="cover-art-container" title="ã‚¯ãƒªãƒƒã‚¯ã§æ­Œè©ã‚’è¡¨ç¤º">
          <div class="cover-art-face cover-art-front">
              <img id="coverArt" src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='250' height='250'><rect width='100%' height='100%' fill='%23333'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' font-family='Arial' font-size='30' fill='%23ccc'>NO ART</text></svg>" alt="ã‚¢ãƒ«ãƒãƒ ã‚«ãƒãƒ¼" />
          </div>
          <div class="cover-art-face cover-art-back">
              <div id="lyricsDisplay">
                  æ­Œè©ã‚’èª­ã¿è¾¼ã¿ä¸­...
              </div>
          </div>
      </div>

      <div id="trackTitle">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„</div>
      <div id="trackArtist">â€”</div>
      
      <div class="mode-status-display">
        <div id="shuffleStatus" class="mode-item"></div>
        <div id="loopStatus" class="mode-item"></div>
      </div>
      
      <div class="seek-container">
        <div id="currentTime" class="time-display">0:00</div>
        <input type="range" id="seekBar" value="0" min="0" max="100">
        <div id="duration" class="time-display">0:00</div>
      </div>
      
      <div class="controls-moved">
        <button class="skip-button" id="playPrevBtn" title="å‰ã®æ›²">â®ï¸</button>
        <button id="seekBackwardBtn" title="10ç§’æˆ»ã‚‹">âª</button>
        <button id="playPauseBtn" class="control-button" title="å†ç”Ÿ/ä¸€æ™‚åœæ­¢">â–¶ï¸</button>
        <button id="seekForwardBtn" title="10ç§’ã‚¹ã‚­ãƒƒãƒ—">â©</button>
        <button class="skip-button" id="playNextBtn" title="æ¬¡ã®æ›²">â­ï¸</button>
      </div>

    </div>
    
    <div class="control-panel">
        <div class="modes">
            <div class="section-title">ğŸ”Š ãƒ¬ãƒ™ãƒ«ãƒ¡ãƒ¼ã‚¿ãƒ¼</div>
            <div class="mixer-container">
                <div class="channel-label">L</div>
                <div class="mixer-bar">
                    <div id="mixerBarL" class="mixer-bar-fill"></div>
                    <div id="peakHoldL" class="peak-hold-indicator"></div> </div>
            </div>
            <div class="mixer-container">
                <div class="channel-label">R</div>
                <div class="mixer-bar">
                    <div id="mixerBarR" class="mixer-bar-fill"></div>
                    <div id="peakHoldR" class="peak-hold-indicator"></div> </div>
            </div>
        </div>

        <div class="modes">
            <div class="section-title">âš™ï¸ ãƒœãƒªãƒ¥ãƒ¼ãƒ  & ãƒ¢ãƒ¼ãƒ‰</div>
            <div class="volume-container">
                <span style="font-size:0.9em; color: var(--text-light); white-space: nowrap;">éŸ³é‡: </span>
                <input type="range" id="volumeSlider" min="0" max="200" value="100">
                <span id="volumePercentage" style="font-size:0.9em; width: 35px; text-align: right; color: var(--accent-color); cursor: pointer; user-select: none;">100%</span>
            </div>
            
            <div class="mode-buttons">
                <button id="loopBtn">ãƒªãƒ”ãƒ¼ãƒˆ</button>
                <button id="shuffleBtn">ã‚·ãƒ£ãƒƒãƒ•ãƒ«</button>
            </div>
        </div>
    </div> 

    <audio id="player" preload="auto"></audio>
  </div>

  <script>
    // ** PWA Service Worker Registration **
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('./sw.js', { scope: './' })
        .then(reg => {
            console.log('ServiceWorker registered:', reg);
            showNotification('Service Worker ç™»éŒ²æ¸ˆã¿', false, 2000);

            // æ–°ã—ã„ SW ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚ŒãŸã‚‰ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«é€šçŸ¥
            reg.addEventListener('updatefound', () => {
                const newWorker = reg.installing;
                newWorker.addEventListener('statechange', () => {
                    if (newWorker.state === 'installed') {
                        if (navigator.serviceWorker.controller) {
                            // æ›´æ–°é©ç”¨å¯èƒ½
                            showNotification('æ–°ã—ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’æ¤œå‡ºã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã¨æ›´æ–°ã•ã‚Œã¾ã™ã€‚', false, 4000);
                        } else {
                            // åˆå›ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
                            showNotification('ã‚¢ãƒ—ãƒªãŒã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã§ä½¿ç”¨ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚', false, 3000);
                        }
                    }
                });
            });

        }).catch(err => {
            console.warn('ServiceWorker registration failed:', err);
            showNotification('Service Worker ã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸã€‚', true, 3000);
        });

        // æ—©æœŸã«æ–°ã—ã„SWã‚’æœ‰åŠ¹åŒ–ã—ãŸã„å ´åˆï¼ˆé–‹ç™ºæ™‚å‘ã‘ï¼‰
        navigator.serviceWorker.addEventListener('message', (ev) => {
            if (ev.data && ev.data.type === 'SKIP_WAITING') {
                navigator.serviceWorker.getRegistration().then(reg => {
                    if (reg && reg.waiting) reg.waiting.postMessage({ type: 'SKIP_WAITING' });
                });
            }
        });
    }
    
    // --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
    const playlists = [];
    const PLAYER_STATE_KEY = 'dmplayer_state_v3'; 
    
    // DOMè¦ç´ 
    let audioList, player, notificationContainer, settingsOverlay, debugToggle, nextTrackNotificationToggle;
    let trackDetailsOverlay, currentTrackInfoDetails, volumeSlider, volumePercentage;
    let shuffleStatus, loopStatus, playPauseBtn, seekBackwardBtn, seekForwardBtn, playNextBtn, playPrevBtn;
    let coverArtContainer, lyricsDisplay, crossfadeDurationSlider, crossfadeValueDisplay;
    let metadataEditForm, editTitleInput, editArtistInput, saveMetadataBtn, toggleEditBtn;
    let peakHoldL, peakHoldR, mixerBarL, mixerBarR;
    let seekBar, currentTimeDisplay, durationDisplay;
    let fileInput, trackTitle, trackArtist, coverArt;
    let optionsBtn, settingsBtn, closeSettingsBtn, helpBtn, closeDetailsBtn;

    // â­ ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼é–¢é€£ã®DOMè¦ç´ 
    let visualizerCanvas, visualizerCtx; 
    let visualizerToggle; 

    // çŠ¶æ…‹å¤‰æ•°
    let currentIndex = 0;
    let isLoop = 'off'; 
    let isShuffle = false;
    let isSeeking = false; 
    let nextTrackNotificationSent = false; 
    let isDebugging = false; 
    let nextTrackNotificationEnabled = true; 
    let isVisualizerEnabled = false; 
    let wasUserInitiatedPlay = false; 
    let CROSSFADE_DURATION = 1.5; 
    let isSwitchingTrack = false; 

    // AudioContexté–¢é€£
    let audioContext, gainNode, analyserL, analyserR, splitter, source;
    // â­ ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ç”¨ã®AnalyserNode
    let analyserMain; 
    let frequencyData; 
    
    let isConnected = false; 
    let rafId = null;
    let peakLevelL = 0;
    let peakLevelR = 0;
    let peakDecayRate = 0.99; 
    const DEFAULT_COVER_SRC = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='250' height='250'><rect width='100%' height='100%' fill='%23333'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' font-family='Arial' font-size='30' fill='%23ccc'>NO ART</text></svg>";
    
    // IndexedDBé–¢é€£
    const DB_NAME = 'DmPlayerDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'CustomMetadata';
    let db;

    // --- åˆæœŸåŒ– ---
    document.addEventListener('DOMContentLoaded', () => {
        // DOMè¦ç´ ã®å–å¾—
        audioList = document.getElementById("audioList");
        player = document.getElementById("player");
        notificationContainer = document.getElementById("notificationContainer");
        settingsOverlay = document.getElementById("settingsOverlay");
        debugToggle = document.getElementById("debugToggle");
        nextTrackNotificationToggle = document.getElementById("nextTrackNotificationToggle");
        trackDetailsOverlay = document.getElementById("trackDetailsOverlay");
        currentTrackInfoDetails = document.getElementById("currentTrackInfoDetails");
        volumeSlider = document.getElementById("volumeSlider");
        volumePercentage = document.getElementById("volumePercentage");
        shuffleStatus = document.getElementById("shuffleStatus");
        loopStatus = document.getElementById("loopStatus");
        playPauseBtn = document.getElementById("playPauseBtn");
        seekBackwardBtn = document.getElementById("seekBackwardBtn");
        seekForwardBtn = document.getElementById("seekForwardBtn");
        playNextBtn = document.getElementById("playNextBtn");
        playPrevBtn = document.getElementById("playPrevBtn");
        coverArtContainer = document.querySelector(".cover-art-container");
        lyricsDisplay = document.getElementById("lyricsDisplay");
        crossfadeDurationSlider = document.getElementById("crossfadeDurationSlider");
        crossfadeValueDisplay = document.getElementById("crossfadeValue");
        metadataEditForm = document.getElementById("metadataEditForm");
        editTitleInput = document.getElementById("editTitle");
        editArtistInput = document.getElementById("editArtist");
        saveMetadataBtn = document.getElementById("saveMetadataBtn");
        toggleEditBtn = document.getElementById("toggleEditBtn");
        peakHoldL = document.getElementById("peakHoldL");
        peakHoldR = document.getElementById("peakHoldR");
        mixerBarL = document.getElementById("mixerBarL");
        mixerBarR = document.getElementById("mixerBarR");
        seekBar = document.getElementById("seekBar");
        currentTimeDisplay = document.getElementById("currentTime");
        durationDisplay = document.getElementById("duration");
        fileInput = document.getElementById("fileInput");
        trackTitle = document.getElementById("trackTitle");
        trackArtist = document.getElementById("trackArtist");
        coverArt = document.getElementById("coverArt");
        optionsBtn = document.getElementById("optionsBtn");
        settingsBtn = document.getElementById("settingsBtn");
        closeSettingsBtn = document.getElementById("closeSettingsBtn");
        helpBtn = document.getElementById("helpBtn");
        closeDetailsBtn = document.getElementById("closeDetailsBtn");
        const loopBtnElement = document.getElementById("loopBtn");
        const shuffleBtnElement = document.getElementById("shuffleBtn");
        
        // â­ ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼é–¢é€£ã®DOMè¦ç´ ã‚’å–å¾—
        visualizerCanvas = document.getElementById("visualizerCanvas");
        visualizerToggle = document.getElementById("visualizerToggle");
        visualizerCtx = visualizerCanvas.getContext("2d");


        // AudioContextã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioContext = new AudioContext();
        gainNode = audioContext.createGain();
        gainNode.gain.value = 1.0; 
        analyserL = audioContext.createAnalyser();
        analyserR = audioContext.createAnalyser();
        
        // â­ ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ç”¨ã®AnalyserNodeã‚’æ–°è¨­
        analyserMain = audioContext.createAnalyser();
        analyserMain.fftSize = 256; 
        frequencyData = new Uint8Array(analyserMain.frequencyBinCount);
        
        analyserL.fftSize = 2048; 
        analyserR.fftSize = 2048;
        analyserL.smoothingTimeConstant = 0.5;
        analyserR.smoothingTimeConstant = 0.5;
        splitter = audioContext.createChannelSplitter(2);

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®ç™»éŒ²
        fileInput.addEventListener('change', handleFileInputChange);
        playPauseBtn.onclick = () => handleUserAction(togglePlayPause);
        seekBackwardBtn.onclick = () => handleUserAction(seekBackward);
        seekForwardBtn.onclick = () => handleUserAction(seekForward);
        playNextBtn.onclick = () => handleUserAction(playNext);
        playPrevBtn.onclick = () => handleUserAction(playPrev);
        
        loopBtnElement.onclick = () => handleUserAction(toggleLoop);
        shuffleBtnElement.onclick = () => handleUserAction(toggleShuffle);
        
        optionsBtn.onclick = () => handleUserAction(showTrackDetails);
        settingsBtn.onclick = () => handleUserAction(showSettings);
        closeSettingsBtn.onclick = hideSettings;
        closeDetailsBtn.onclick = hideTrackDetails;
        toggleEditBtn.onclick = toggleMetadataEdit;
        saveMetadataBtn.onclick = saveEditedMetadata;
        coverArtContainer.onclick = () => handleUserAction(toggleFlip);
        helpBtn.onclick = () => showNotification("DmPlayer v2.0.16 - Offline Player (Visualizer UI Fix)", false, 3000); // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’æ›´æ–°
        volumePercentage.onclick = resetVolumeToDefault;


        volumeSlider.addEventListener('input', (e) => updateVolume(e.target.value));
        crossfadeDurationSlider.addEventListener('input', (e) => {
            CROSSFADE_DURATION = parseFloat(e.target.value);
            crossfadeValueDisplay.textContent = CROSSFADE_DURATION.toFixed(1);
            saveState();
        });
        debugToggle.addEventListener('change', (e) => {
            isDebugging = e.target.checked;
            showNotification(isDebugging ? 'ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ON' : 'ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰OFF', false, 2000);
            saveState();
        });
        nextTrackNotificationToggle.addEventListener('change', (e) => {
            nextTrackNotificationEnabled = e.target.checked;
            saveState();
        });
        
        // â­ ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ãƒˆã‚°ãƒ«ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
        visualizerToggle.addEventListener('change', (e) => {
            isVisualizerEnabled = e.target.checked;
            const msg = isVisualizerEnabled ? 'ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ ON' : 'ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ OFF';
            showNotification(msg, false, 2000);
            updateVisualizerState();
            if(!player.paused) {
                 // å†ç”Ÿä¸­ã«ON/OFFã—ãŸå ´åˆã€æç”»ãƒ«ãƒ¼ãƒ—ã‚’å†é–‹/åœæ­¢ã™ã‚‹
                 if (rafId) cancelAnimationFrame(rafId);
                 if (isVisualizerEnabled) {
                     rafId = requestAnimationFrame(drawVisualizer);
                 } else {
                     rafId = requestAnimationFrame(drawMixer);
                 }
            }
            saveState();
        });

        // ã‚·ãƒ¼ã‚¯ãƒãƒ¼é–¢é€£
        seekBar.addEventListener('mousedown', () => { isSeeking = true; });
        seekBar.addEventListener('touchstart', () => { isSeeking = true; });
        const seekEndHandler = () => {
             isSeeking = false;
             const duration = player.duration;
             if (!isNaN(duration) && isFinite(duration) && duration > 0) {
                 player.currentTime = (seekBar.value / 100) * duration;
             }
             updateSeekBar(player.currentTime);
             saveState();
        };
        seekBar.addEventListener('mouseup', seekEndHandler);
        seekBar.addEventListener('touchend', seekEndHandler);
        seekBar.addEventListener('input', () => {
             const duration = player.duration;
             if (!isNaN(duration) && isFinite(duration) && duration > 0) {
                 const tempTime = (seekBar.value / 100) * duration;
                 currentTimeDisplay.textContent = formatTime(tempTime);
                 seekBar.style.setProperty('--progress', `${seekBar.value}%`);
             }
        });

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ
        player.addEventListener('loadedmetadata', onLoadedMetadata);
        player.addEventListener('timeupdate', onTimeUpdate);
        player.addEventListener('ended', onTrackEnded);
        player.addEventListener('error', onPlayerError);
        player.addEventListener('play', onPlay);
        player.addEventListener('pause', onPause);


        // åˆæœŸåŒ–å‡¦ç†
        initDB().finally(() => {
            updateVolume(volumeSlider.value); 
            loadState(); 
            
            // â­ ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ã®åˆæœŸçŠ¶æ…‹ã‚’åæ˜ 
            updateVisualizerState();
            
            updateAudioList(); 
            updateModeStatusDisplay(); 
            updateLoopButton();
            
            if (playlists.length === 0) {
                resetDisplayedTrackInfo();
            } else {
                loadTrack(currentIndex); 
            }
            updatePlayerStatusDisplay(true); 
            showNotification("DmPlayer v2.0.16 èµ·å‹•å®Œäº† (Visualizer UI Fix)ã€‚", false, 1500, true); // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’æ›´æ–°
        });
        
        // ãƒªã‚µã‚¤ã‚ºæ™‚ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºèª¿æ•´
        window.addEventListener('resize', updateVisualizerCanvasSize);
        // åˆæœŸã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºèª¿æ•´
        updateVisualizerCanvasSize(); 
    });
    
    // --- DBé–¢æ•° (å¤‰æ›´ãªã—) ---
    function initDB() {
        return new Promise((resolve, reject) => {
            if (!window.indexedDB) { return resolve(); }
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onerror = (e) => reject(e.target.error);
            request.onsuccess = (e) => { db = e.target.result; resolve(); };
            request.onupgradeneeded = (e) => {
                db = e.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    db.createObjectStore(STORE_NAME, { keyPath: 'fileName' });
                }
            };
        });
    }

    function loadMetadataFromDB(fileName) {
        return new Promise((resolve) => {
            if (!db) return resolve(null);
            const transaction = db.transaction([STORE_NAME], 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.get(fileName);
            request.onsuccess = (e) => resolve(e.target.result || null);
            request.onerror = () => resolve(null);
        });
    }

    function saveMetadataToDB(fileName, data) {
        return new Promise((resolve) => {
            if (!db) return resolve();
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.put({ fileName, ...data });
            request.onsuccess = resolve;
            request.onerror = resolve;
        });
    }


    // --- ãƒãƒ³ãƒ‰ãƒ©é–¢æ•° (å¤‰æ›´ãªã—) ---
    async function handleFileInputChange(event) {
        const files = Array.from(event.target.files);
        if (files.length === 0) return;

        // æ—¢å­˜ã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚’ã‚¯ãƒªã‚¢
        if (playlists.length > 0 && playlists.some(f => f.isPlaceholder)) {
            playlists.length = 0;
            currentIndex = 0;
        }

        let firstNewIndex = -1;
        const tagPromises = files.map((file, i) => {
            const index = playlists.length + i;
            if (firstNewIndex === -1) firstNewIndex = index;

            const fileName = file.name || `unknown_${Date.now()}_${index}`;
            
            // ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å…ˆã«ä½œæˆã—ã€ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ 
            const track = {
                file: file,
                name: fileName,
                title: removeExtension(fileName),
                artist: 'Unknown Artist',
                album: 'Unknown Album',
                lyrics: 'ã‚¿ã‚°èª­ã¿è¾¼ã¿ä¸­...',
                coverArt: DEFAULT_COVER_SRC,
                isPlaceholder: true,
                duration: 0,
                bitrate: null,
                sampleRate: null
            };
            playlists.push(track);
            
            // ã‚¿ã‚°èª­ã¿è¾¼ã¿ã‚’Promiseã§ãƒ©ãƒƒãƒ—
            return new Promise((resolve) => {
                jsmediatags.read(file, {
                    onSuccess: (tag) => { 
                        // Promise.resolve().then()ã§å®Ÿè¡Œã‚’é…å»¶ã—ã€ã‚¹ã‚¿ãƒƒã‚¯ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã‚’å›é¿
                        Promise.resolve().then(async () => {
                            try {
                                const title = tag.tags.title || tag.tags["\u00A9nam"] || removeExtension(file.name);
                                const artist = tag.tags.artist || tag.tags["\u00A9art"] || 'Unknown Artist';
                                const album = tag.tags.album || tag.tags["\u00A9alb"] || 'Unknown Album';
                                
                                let lyricsText = 'æ­Œè©æƒ…å ±ãªã—';

                                if (tag.tags.USLT && tag.tags.USLT.data) {
                                    lyricsText = tag.tags.USLT.data;
                                } 
                                else if (tag.tags.lyrics) {
                                    lyricsText = tag.tags.lyrics;
                                }
                                else if (tag.tags["\u00A9lyr"] && tag.tags["\u00A9lyr"].data) { 
                                    lyricsText = tag.tags["\u00A9lyr"].data;
                                }
                                else if (tag.tags.comment && tag.tags.comment.length > 0) {
                                    const commentData = tag.tags.comment[0].text || tag.tags.comment[0].data || tag.tags.comment[0];
                                    if (commentData && commentData.length > 50) { 
                                        lyricsText = commentData;
                                    }
                                }

                                // DBã‹ã‚‰ã‚«ã‚¹ã‚¿ãƒ ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ­ãƒ¼ãƒ‰
                                const custom = await loadMetadataFromDB(file.name);
                                
                                // ãƒˆãƒ©ãƒƒã‚¯æƒ…å ±ã«åæ˜ 
                                track.title = custom ? custom.title : title;
                                track.artist = custom ? custom.artist : artist;
                                track.album = album;
                                track.lyrics = lyricsText; 
                                track.isPlaceholder = false;

                                if (tag.tags.picture) {
                                    try {
                                        const picture = tag.tags.picture;
                                        const dataUrl = await pictureToDataUrl(picture);
                                        track.coverArt = dataUrl;
                                    } catch (e) {
                                        console.warn('pictureToDataUrl failed', e);
                                    }
                                }
                            } catch (e) {
                                 console.error('Processing Tag Error:', e);
                                 track.isPlaceholder = false; 
                                 track.lyrics = 'ã‚¿ã‚°æƒ…å ±ã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚';
                            } finally {
                                resolve(); 
                            }
                        }).catch(e => {
                             console.error('Deferred Tag Processing Error (Stack):', e);
                             track.isPlaceholder = false; 
                             track.lyrics = 'ã‚¿ã‚°æƒ…å ±ã®å‡¦ç†ä¸­ã«æ·±åˆ»ãªã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚';
                             resolve(); 
                        });
                    },
                    onError: (e) => {
                        console.error('Tag Error:', e);
                        track.isPlaceholder = false;
                        track.lyrics = 'ã‚¿ã‚°æƒ…å ±ã®å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚';
                        resolve(); 
                    }
                });
            });
        });
        
        // å‡¦ç†ä¸­ã®UIæ›´æ–° (å…ˆè¡Œã—ã¦ãƒªã‚¹ãƒˆã‚’è¡¨ç¤º)
        updateAudioList(); 
        showNotification(`${files.length}ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ä¸­...`, false, 2000);

        // ã™ã¹ã¦ã®ã‚¿ã‚°èª­ã¿è¾¼ã¿ãŒå®Œäº†ã™ã‚‹ã®ã‚’å¾…ã¤
        await Promise.all(tagPromises);
        
        // æœ€çµ‚å‡¦ç†
        updateAudioList();
        showNotification(`${files.length}ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã€‚ã‚¿ã‚°èª­ã¿è¾¼ã¿å®Œäº†ã€‚`, false, 3000);
        if (player.paused && playlists.length > 0) {
            currentIndex = firstNewIndex;
            loadTrack(currentIndex);
        }
        saveState();
    }

    // onLoadedMetadata (å¤‰æ›´ãªã—)
    function onLoadedMetadata() {
        if (!isNaN(player.duration)) {
            durationDisplay.textContent = formatTime(player.duration);
            seekBar.max = 100;
            
            if (playlists[currentIndex]) {
                const tr = playlists[currentIndex];
                const fileSize = tr.file ? tr.file.size : 0; 
                
                tr.duration = player.duration;
                tr.sampleRate = audioContext.sampleRate;
                
                if (fileSize && tr.duration) {
                     tr.bitrate = Math.round((fileSize * 8) / tr.duration / 1000);
                }
            }
            
            if (trackDetailsOverlay.classList.contains('show')) loadAlbumArt(playlists[currentIndex]);
            
            if (!isConnected) connectAudioGraph();

            // ãƒˆãƒ©ãƒƒã‚¯åˆ‡ã‚Šæ›¿ãˆå¾Œã®è‡ªå‹•å†ç”Ÿãƒ»ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
            if (isSwitchingTrack) {
                isSwitchingTrack = false; 

                // ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚’é–‹å§‹
                const vol = volumeSlider.value / 100.0;
                gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                if (CROSSFADE_DURATION > 0) {
                     gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime);
                     gainNode.gain.linearRampToValueAtTime(vol, audioContext.currentTime + CROSSFADE_DURATION);
                } else {
                     gainNode.gain.setValueAtTime(vol, audioContext.currentTime); 
                }
                
                // å®‰å…¨ã«å†ç”Ÿã‚’è©¦ã¿ã‚‹
                player.play().catch(e => {
                    if (e.name !== 'AbortError') { 
                        showNotification(`å†ç”Ÿãƒ–ãƒ­ãƒƒã‚¯: ${e.name}. æ‰‹å‹•å†ç”ŸãŒå¿…è¦ã§ã™ã€‚`, true, 5000, true);
                    }
                });

            } else {
                 // å¾©å…ƒãƒ­ã‚¸ãƒƒã‚¯ (æ‰‹å‹•ãƒˆãƒ©ãƒƒã‚¯ãƒ­ãƒ¼ãƒ‰æ™‚ã‚„ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚)
                 const savedState = JSON.parse(localStorage.getItem(PLAYER_STATE_KEY) || '{}');
                 if (!wasUserInitiatedPlay && savedState.currentIndex === currentIndex && savedState.playbackPosition > 0) {
                      player.currentTime = savedState.playbackPosition;
                      updateSeekBar(savedState.playbackPosition);
                 }
                 wasUserInitiatedPlay = false;
            }
        }
    }

    function onTimeUpdate() {
        if (!isSeeking) updateSeekBar(player.currentTime);
        if (nextTrackNotificationEnabled && !nextTrackNotificationSent && player.duration - player.currentTime <= 10) {
            if (playlists.length > 1 || isLoop === 'one') {
                let nextIndex = currentIndex;
                if(isShuffle) {
                    // ã‚·ãƒ£ãƒƒãƒ•ãƒ«æ™‚ã¯æ¬¡ã®æ›²ã‚’ç‰¹å®šã™ã‚‹ã®ãŒé›£ã—ã„ãŸã‚ã‚¹ã‚­ãƒƒãƒ—
                } else if (isLoop === 'all' || currentIndex < playlists.length - 1) {
                    nextIndex = (currentIndex + 1) % playlists.length;
                    const nextTitle = playlists[nextIndex].title;
                    showNotification(`æ¬¡ã¯: ${nextTitle}`, false, 4000);
                }
            }
            nextTrackNotificationSent = true;
        }
        saveState(); 
    }
    
    function onTrackEnded() {
        nextTrackNotificationSent = false;
        if (isLoop === 'one') {
            player.currentTime = 0;
            handleUserAction(() => player.play());
            return;
        }
        if (isLoop === 'all' || isShuffle) {
            playNext();
        } else {
            if (currentIndex < playlists.length - 1) {
                playNext();
            } else {
                showNotification("å†ç”Ÿçµ‚äº†", false, 3000);
                player.pause();
                updatePlayerStatusDisplay(true);
            }
        }
    }
    
    function onPlayerError(e) {
        showNotification("å†ç”Ÿã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ", true, 5000);
        updateAudioList();
    }
    
    // onPlay (å¤‰æ›´ãªã—)
    function onPlay() {
        updatePlayerStatusDisplay(false);
        nextTrackNotificationSent = false;
        if (audioContext.state === 'suspended') audioContext.resume();
        
        // â­ ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ãŒæœ‰åŠ¹ãªå ´åˆã€æ–°ã—ã„æç”»ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹
        if(isVisualizerEnabled) {
            if (rafId) cancelAnimationFrame(rafId);
            rafId = requestAnimationFrame(drawVisualizer);
        } else {
            // ãƒŸã‚­ã‚µãƒ¼æç”»ã®ã¿ã‚’ç¶™ç¶š (æ—¢å­˜ã®rafIdãƒ­ã‚¸ãƒƒã‚¯ã‚’å†åˆ©ç”¨)
            if (rafId) cancelAnimationFrame(rafId);
            rafId = requestAnimationFrame(drawMixer);
        }
        
        if (playlists[currentIndex]) setMediaSession(playlists[currentIndex]);
    }
    
    // onPause (å¤‰æ›´ãªã—)
    function onPause() {
        updatePlayerStatusDisplay(true);
        
        // â­ ä¸€æ™‚åœæ­¢æ™‚ã€æç”»ã‚’åœæ­¢
        if (rafId) {
            cancelAnimationFrame(rafId);
            rafId = null;
        }
        // ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ãƒ¢ãƒ¼ãƒ‰ä¸­ã¯ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’éè¡¨ç¤ºã«ã—ãªã„
        if (!isVisualizerEnabled) {
            visualizerCanvas.style.display = 'none';
        }
    }


    // --- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ­ã‚¸ãƒƒã‚¯ (å¤‰æ›´ãªã—) ---
    async function loadTrack(index) {
        if (playlists.length === 0 || index < 0 || index >= playlists.length) return;
        currentIndex = index;
        const file = playlists[index];
        
        if (!file.file) {
             showNotification("ãƒ•ã‚¡ã‚¤ãƒ«å®Ÿä½“ãŒã‚ã‚Šã¾ã›ã‚“ã€‚å†é¸æŠã—ã¦ãã ã•ã„ã€‚", true, 5000);
             return;
        }

        if (player.src) URL.revokeObjectURL(player.src);
        
        const url = URL.createObjectURL(file.file);
        
        player.src = url;
        player.load(); 
        
        loadAlbumArt(file);
        setMediaSession(file); 
        updateAudioList();
        saveState();
    }

    function togglePlayPause() {
        if (playlists.length === 0) return;
        
        connectAudioGraph(); 

        if (player.paused) {
            const vol = volumeSlider.value / 100.0;
            gainNode.gain.cancelScheduledValues(audioContext.currentTime);
            gainNode.gain.setValueAtTime(vol, audioContext.currentTime);

            player.play().then(() => {
                updatePlayerStatusDisplay(false);
                wasUserInitiatedPlay = true;
                showNotification("å†ç”Ÿé–‹å§‹", false, 1000, true);
            }).catch(e => {
                showNotification("å†ç”Ÿãƒ–ãƒ­ãƒƒã‚¯: ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„", true);
            });
        } else {
            gainNode.gain.cancelScheduledValues(audioContext.currentTime);
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            
            player.pause();
            
            setTimeout(() => {
                 if (audioContext && audioContext.state !== 'closed') {
                     gainNode.gain.setValueAtTime(volumeSlider.value / 100.0, audioContext.currentTime);
                 }
            }, 50); 
            
            updatePlayerStatusDisplay(true);
            showNotification("ä¸€æ™‚åœæ­¢", false, 1000, true);
        }
    }
    
    function playNext() {
        if (playlists.length === 0) return;
        
        let next = currentIndex + 1;
        if (isShuffle) {
            next = Math.floor(Math.random() * playlists.length);
        } else if (next >= playlists.length) {
            if (isLoop === 'all') next = 0;
            else return;
        }
        
        isSwitchingTrack = !player.paused; 
        
        if (isSwitchingTrack && CROSSFADE_DURATION > 0) {
             const fadeOutTime = audioContext.currentTime + CROSSFADE_DURATION;
             gainNode.gain.cancelScheduledValues(audioContext.currentTime);
             gainNode.gain.linearRampToValueAtTime(0, fadeOutTime);
             
             setTimeout(() => {
                 loadTrack(next);
             }, CROSSFADE_DURATION * 1000);
        } else {
            loadTrack(next);
        }
    }
    
    function playPrev() {
        if (playlists.length === 0) return;
        if (player.currentTime > 3) {
            player.currentTime = 0;
            return;
        }
        
        let prev = currentIndex - 1;
        if (isShuffle) prev = Math.floor(Math.random() * playlists.length);
        else if (prev < 0) prev = playlists.length - 1;
        
        isSwitchingTrack = !player.paused; 

        if (isSwitchingTrack && CROSSFADE_DURATION > 0) {
             const fadeOutTime = audioContext.currentTime + CROSSFADE_DURATION;
             gainNode.gain.cancelScheduledValues(audioContext.currentTime);
             gainNode.gain.linearRampToValueAtTime(0, fadeOutTime);
             
             setTimeout(() => {
                 loadTrack(prev);
             }, CROSSFADE_DURATION * 1000);
        } else {
            loadTrack(prev);
        }
    }
    
    function seekForward() { player.currentTime = Math.min(player.duration, player.currentTime + 10); }
    function seekBackward() { player.currentTime = Math.max(0, player.currentTime - 10); }


    // --- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ (å¤‰æ›´ãªã—) ---
    function formatTime(s) {
        if (isNaN(s)) return '0:00';
        const m = Math.floor(s / 60);
        const sec = Math.floor(s % 60);
        return `${m}:${sec.toString().padStart(2, '0')}`;
    }
    function formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    function removeExtension(f) {
        return f.replace(/\.[^/.]+$/, "");
    }
    function tryResumeContext() {
        if (audioContext && audioContext.state === 'suspended') audioContext.resume();
    }

    // Accepts a callback and an optional Event object. Many inline handlers pass
    // a callback that expects the click event (to call stopPropagation()).
    // We always try to resume the AudioContext first, then call the callback
    // with the provided event (or undefined).
    function handleUserAction(fn, ev) {
        tryResumeContext();
        try {
            if (typeof fn === 'function') fn(ev);
        } catch (err) {
            console.error('Error in handleUserAction callback', err);
            showNotification('æ“ä½œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚', true, 3000);
        }
    }
    function showNotification(msg, isErr, dur = 3000, isDebug = false) {
        if (isDebug && !isDebugging) return;
        
        const div = document.createElement('div');
        div.className = `notification-message ${isErr ? 'error' : ''} ${isDebug ? 'debug' : ''}`;
        div.textContent = msg;
        notificationContainer.appendChild(div);
        setTimeout(() => div.classList.add('show'), 10);
        setTimeout(() => {
            div.classList.remove('show');
            setTimeout(() => div.remove(), 500);
        }, dur);
    }
    
    // --- UIåˆ¶å¾¡é–¢æ•° (ä¸€éƒ¨å¤‰æ›´ã‚ã‚Š) ---
    function updateModeStatusDisplay() {
        shuffleStatus.innerHTML = isShuffle ? 'ğŸ”€ ON' : 'â–¶ OFF';
        shuffleStatus.className = `mode-item ${isShuffle ? 'active' : ''}`;
        
        let lt = 'â†³ OFF';
        if (isLoop === 'all') lt = 'âŸ² ALL';
        if (isLoop === 'one') lt = 'â‚ ONE';
        loopStatus.innerHTML = lt;
        loopStatus.className = `mode-item ${isLoop !== 'off' ? 'active' : ''}`;
    }
    
    function updateLoopButton() {
        const btn = document.getElementById("loopBtn");
        btn.textContent = `ãƒªãƒ”ãƒ¼ãƒˆ (${isLoop.toUpperCase()})`;
    }

    function toggleLoop() {
        if (isLoop === 'off') isLoop = 'all';
        else if (isLoop === 'all') isLoop = 'one';
        else isLoop = 'off';
        updateLoopButton();
        updateModeStatusDisplay();
        saveState();
    }

    function toggleShuffle() {
        isShuffle = !isShuffle;
        document.getElementById("shuffleBtn").textContent = `ã‚·ãƒ£ãƒƒãƒ•ãƒ« (${isShuffle ? 'ON' : 'OFF'})`;
        updateModeStatusDisplay();
        saveState();
    }
    
    function updateVolume(value) {
        const vol = parseFloat(value) / 100.0;
        volumePercentage.textContent = `${value}%`;
        if (gainNode) {
            gainNode.gain.cancelScheduledValues(audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(vol, audioContext.currentTime + 0.05); 
        }
        saveState();
    }

    function resetVolumeToDefault() {
        volumeSlider.value = 100;
        updateVolume(100);
    }

    function updateSeekBar(currentTime) {
        const duration = player.duration;
        if (isNaN(duration) || !isFinite(duration) || duration === 0) return;

        const progress = (currentTime / duration) * 100;
        seekBar.value = progress;
        currentTimeDisplay.textContent = formatTime(currentTime);
        seekBar.style.setProperty('--progress', `${progress}%`);
    }

    function updatePlayerStatusDisplay(isPaused) {
        if (playlists.length === 0) {
            playPauseBtn.innerHTML = 'â–¶ï¸';
            playPauseBtn.parentElement.classList.remove('player-ready');
            trackTitle.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„';
            trackArtist.textContent = 'â€”';
            return;
        }

        const track = playlists[currentIndex];
        trackTitle.textContent = track ? track.title : 'ãƒˆãƒ©ãƒƒã‚¯ãŒã‚ã‚Šã¾ã›ã‚“';
        trackArtist.textContent = track ? track.artist : 'â€”';

        if (isPaused) {
            playPauseBtn.innerHTML = 'â–¶ï¸';
            playPauseBtn.parentElement.classList.add('player-ready');
        } else {
            playPauseBtn.innerHTML = 'â¸ï¸';
            playPauseBtn.parentElement.classList.remove('player-ready');
        }
    }
    
    function moveTrack(fromIndex, toIndex) {
        if (fromIndex < 0 || fromIndex >= playlists.length || toIndex < 0 || toIndex >= playlists.length || fromIndex === toIndex) return;
        
        const [movedTrack] = playlists.splice(fromIndex, 1);
        playlists.splice(toIndex, 0, movedTrack);
        
        if (currentIndex === fromIndex) {
            currentIndex = toIndex;
        } else if (fromIndex < currentIndex && toIndex >= currentIndex) {
            currentIndex--;
        } else if (fromIndex > currentIndex && toIndex <= currentIndex) {
            currentIndex++;
        }

        updateAudioList();
        showNotification(`"${movedTrack.title}"ã‚’ç§»å‹•ã—ã¾ã—ãŸã€‚`, false, 2000);
        saveState();
    }

    function moveTrackUp(index) {
        if (index > 0) {
            moveTrack(index, index - 1);
        }
    }

    function moveTrackDown(index) {
        if (index < playlists.length - 1) {
            moveTrack(index, index + 1);
        }
    }
    
    function updateAudioList() {
        audioList.innerHTML = '';
        if (playlists.length === 0) {
            audioList.innerHTML = '<div class="queue-item placeholder-track">ã‚­ãƒ¥ãƒ¼ã¯ç©ºã§ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚</div>';
            return;
        }

        playlists.forEach((track, index) => {
            const item = document.createElement('div');
            item.className = `queue-item ${index === currentIndex ? 'active-track' : ''} ${track.isPlaceholder ? 'placeholder-track' : ''}`;
            item.dataset.index = index;

            item.innerHTML = `
                <div class="queue-index">${index === currentIndex ? (player.paused ? 'â¸' : 'ğŸ¶') : index + 1}</div>
                <div class="track-info-container" onclick="handleUserAction(() => handleTrackSelect(${index}))">
                    <div class="track-title-display">${track.title}</div>
                    <div class="track-artist-display">${track.artist}</div>
                </div>
                <div class="queue-controls">
                    <button class="queue-control-btn" onclick="handleUserAction((e) => { e.stopPropagation(); moveTrackUp(${index}); }, event)" title="ä¸Šã«ç§»å‹•" ${index === 0 ? 'disabled' : ''}>â¬†ï¸</button>
                    <button class="queue-control-btn" onclick="handleUserAction((e) => { e.stopPropagation(); moveTrackDown(${index}); }, event)" title="ä¸‹ã«ç§»å‹•" ${index < playlists.length - 1 ? 'disabled' : ''}>â¬‡ï¸</button>
                    <button class="queue-control-btn" onclick="handleUserAction((e) => { e.stopPropagation(); removeTrack(${index}); }, event)" title="ã‚­ãƒ¥ãƒ¼ã‹ã‚‰å‰Šé™¤">âŒ</button>
                </div>
            `;
            audioList.appendChild(item);
        });
    }

    function handleTrackSelect(index) {
        if (index === currentIndex) {
            togglePlayPause();
        } else {
            isSwitchingTrack = false; 
            loadTrack(index);
            togglePlayPause(); 
        }
    }

    function removeTrack(index) {
        if (index === currentIndex) {
            player.pause();
            playlists.splice(index, 1);
            if (playlists.length > 0) {
                currentIndex = Math.min(index, playlists.length - 1);
                loadTrack(currentIndex);
            } else {
                currentIndex = 0;
                resetDisplayedTrackInfo();
            }
        } else {
            playlists.splice(index, 1);
            if (index < currentIndex) currentIndex--;
        }
        updateAudioList();
        saveState();
    }
    
    function resetDisplayedTrackInfo() {
        trackTitle.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„';
        trackArtist.textContent = 'â€”';
        coverArt.src = DEFAULT_COVER_SRC;
        durationDisplay.textContent = '0:00';
        currentTimeDisplay.textContent = '0:00';
        seekBar.value = 0;
        lyricsDisplay.textContent = 'æ­Œè©ãªã—';
    }

    // --- UIã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤åˆ¶å¾¡ (å¤‰æ›´ãªã—) ---
    function showSettings() {
        settingsOverlay.classList.add('show');
    }
    function hideSettings() {
        settingsOverlay.classList.remove('show');
    }

    function showTrackDetails() {
        const track = playlists[currentIndex];
        if (!track || track.isPlaceholder) {
            showNotification("ãƒˆãƒ©ãƒƒã‚¯æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“ã€‚", false, 2000);
            return;
        }
        
        const fileSize = track.file ? formatBytes(track.file.size) : 'N/A';
        const fileType = track.file ? track.file.type : 'N/A';
        const durationText = formatTime(track.duration || 0);

        currentTrackInfoDetails.innerHTML = `
            <strong>ã‚¿ã‚¤ãƒˆãƒ«:</strong> ${track.title}<br>
            <strong>ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆ:</strong> ${track.artist}<br>
            <strong>ã‚¢ãƒ«ãƒãƒ :</strong> ${track.album || 'ä¸æ˜'}<br>
            <br>
            <strong>ãƒ•ã‚¡ã‚¤ãƒ«å:</strong> ${track.name}<br>
            <strong>ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º:</strong> ${fileSize}<br>
            <strong>ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼:</strong> ${fileType}<br>
            <strong>æ¼”å¥æ™‚é–“:</strong> ${durationText}<br>
            <strong>ãƒ“ãƒƒãƒˆãƒ¬ãƒ¼ãƒˆ:</strong> ${track.bitrate ? `${track.bitrate} kbps` : 'N/A'}<br>
            <strong>ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆ:</strong> ${track.sampleRate || 'N/A'} Hz<br>
            
            <div id="metadataEditForm" style="display: none;">
                <div class="input-group">
                    <label for="editTitle">ã‚¿ã‚¤ãƒˆãƒ«</label>
                    <input type="text" id="editTitle" value="${track.title || ''}">
                </div>
                <div class="input-group">
                    <label for="editArtist">ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆ</label>
                    <input type="text" id="editArtist" value="${track.artist || ''}">
                </div>
                <button class="footer-btn" id="saveMetadataBtn">ã‚¿ã‚°ã‚’ä¿å­˜ã—ã¦é©ç”¨</button>
            </div>
        `;
        
        document.getElementById("saveMetadataBtn").onclick = saveEditedMetadata;
        
        toggleEditBtn.textContent = 'ã‚¿ã‚°ã‚’ç·¨é›†';
        metadataEditForm.style.display = 'none';
        
        trackDetailsOverlay.classList.add('show');
    }

    function hideTrackDetails() {
        trackDetailsOverlay.classList.remove('show');
    }

    function toggleMetadataEdit() {
        const form = document.getElementById("metadataEditForm");
        const isEditing = form.style.display === 'block';
        form.style.display = isEditing ? 'none' : 'block';
        toggleEditBtn.textContent = isEditing ? 'ç·¨é›†ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«' : 'ã‚¿ã‚°ã‚’ç·¨é›†';
    }
    
    function saveEditedMetadata() {
        const track = playlists[currentIndex];
        if (!track || !track.file) return;

        const newTitle = document.getElementById("editTitle").value.trim();
        const newArtist = document.getElementById("editArtist").value.trim();
        
        if (!newTitle || !newArtist) {
            showNotification("ã‚¿ã‚¤ãƒˆãƒ«ã¨ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆåã¯å¿…é ˆã§ã™ã€‚", true);
            return;
        }
        
        track.title = newTitle;
        track.artist = newArtist;
        
        saveMetadataToDB(track.name, { title: newTitle, artist: newArtist })
            .then(() => {
                showNotification("ã‚¿ã‚°æƒ…å ±ã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚", false);
                // UIã‚’æ›´æ–°
                trackTitle.textContent = newTitle;
                trackArtist.textContent = newArtist;
                updateAudioList();
                hideTrackDetails();
            })
            .catch(() => {
                showNotification("ã‚¿ã‚°æƒ…å ±ã®ä¿å­˜ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚", true);
            });
    }

    // --- AudioContext/Mixer/Visualizeré–¢é€£ ---
    
    // â­ ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ã®æç”»ãƒ«ãƒ¼ãƒ—é–¢æ•°
    function drawVisualizer() {
        if (!visualizerCtx) {
            // Canvas ãŒæœªåˆæœŸåŒ–ãªã‚‰ä½•ã‚‚ã—ãªã„
            rafId = requestAnimationFrame(drawVisualizer);
            return;
        }

        if (!isVisualizerEnabled) {
            visualizerCanvas.style.display = 'none';
            rafId = null;
            return;
        }

        // å†ç”ŸãŒæ­¢ã¾ã£ã¦ã„ã‚‹å ´åˆã¯æç”»ã‚’æ­¢ã‚ã‚‹ï¼ˆã‚­ãƒ£ãƒ³ãƒã‚¹ã¯è¡¨ç¤ºã—ãŸã¾ã¾ï¼‰
        if (player.paused) {
            rafId = null;
            return;
        }
        
        // ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼æç”»
        visualizerCanvas.style.display = 'block';
        analyserMain.getByteFrequencyData(frequencyData);

        const width = visualizerCanvas.width || visualizerCanvas.clientWidth;
        const height = visualizerCanvas.height || visualizerCanvas.clientHeight;
        visualizerCtx.clearRect(0, 0, width, height);

        const bufferLength = analyserMain.frequencyBinCount;

        // Check if analyser returned no data (common when the audio graph isn't connected)
        const isAllZero = frequencyData.every(v => v === 0);
        if (isAllZero) {
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ™‚é–“é ˜åŸŸã®ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æŒ¯å¹…ã‚’è¨ˆæ¸¬ã—ã¦å˜ç´”ãªãƒãƒ¼ã‚’æç”»
            const timeData = new Uint8Array(analyserMain.fftSize || 2048);
            try {
                analyserMain.getByteTimeDomainData(timeData);
            } catch (e) {
                // getByteTimeDomainData ãŒå¤±æ•—ã™ã‚‹å ´åˆã¯æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ ã¸
                rafId = requestAnimationFrame(drawVisualizer);
                return;
            }

            let sum = 0;
            for (let i = 0; i < timeData.length; i++) {
                const n = (timeData[i] - 128) / 128;
                sum += n * n;
            }
            const rms = Math.sqrt(sum / timeData.length);
            const amp = Math.min(1, rms * 4);

            const barW = Math.max(4, Math.floor(width * 0.1));
            const barH = amp * height;
            visualizerCtx.fillStyle = 'rgba(120,200,255,0.9)';
            visualizerCtx.fillRect((width - barW) / 2, height - barH, barW, barH);
        } else {
            const barWidth = (width / bufferLength) * 1.8;
            let x = 0;
            for (let i = 0; i < bufferLength; i++) {
                const magnitude = frequencyData[i];
                const barHeight = (magnitude / 255) * height * 0.8;
                const hue = Math.floor((i / bufferLength) * 240);
                visualizerCtx.fillStyle = `hsl(${hue}, 80%, ${50 - (magnitude / 6)}%)`;
                visualizerCtx.fillRect(x, height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }


        // ãƒŸã‚­ã‚µãƒ¼ã®æç”» (ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ãŒONã®å ´åˆã‚‚ç¶™ç¶š)
        drawMixer();
        
        rafId = requestAnimationFrame(drawVisualizer);
    }
    
    // ãƒŸã‚­ã‚µãƒ¼ã®æç”» 
    function drawMixer() {
        if (player.paused && !isVisualizerEnabled) {
            rafId = null;
            return;
        }
        
        const rmsL = calculateRMS(analyserL);
        const rmsR = calculateRMS(analyserR);
        mixerBarL.style.width = `${rmsL}%`;
        mixerBarR.style.width = `${rmsR}%`;
        
        peakLevelL = Math.max(peakLevelL * peakDecayRate, rmsL);
        peakLevelR = Math.max(peakLevelR * peakDecayRate, rmsR);
        
        peakHoldL.style.transform = `translateX(${Math.max(0, peakLevelL)}%) translateX(-100%)`;
        peakHoldR.style.transform = `translateX(${Math.max(0, peakLevelR)}%) translateX(-100%)`;

        if (isVisualizerEnabled && !player.paused) {
            return; // ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼ãƒ¢ãƒ¼ãƒ‰ONã§å†ç”Ÿä¸­ã¯drawVisualizerãŒã“ã‚Œã‚’å‘¼ã³å‡ºã™ãŸã‚ã€äºŒé‡ã®rafã‚’é¿ã‘ã‚‹
        }
        
        rafId = requestAnimationFrame(drawMixer);
    }
    
    function updateVisualizerCanvasSize() {
        const screen = document.getElementById("playerScreen");
        if (screen) {
            // Use devicePixelRatio to set the canvas internal buffer size so drawing is visible
            const dpr = window.devicePixelRatio || 1;
            const w = Math.max(1, Math.floor(screen.clientWidth));
            const h = Math.max(1, Math.floor(screen.clientHeight));
            visualizerCanvas.style.width = w + 'px';
            visualizerCanvas.style.height = h + 'px';
            visualizerCanvas.width = Math.max(1, Math.floor(w * dpr));
            visualizerCanvas.height = Math.max(1, Math.floor(h * dpr));
            // Reset transform and scale for high-DPI
            if (visualizerCtx && typeof visualizerCtx.setTransform === 'function') {
                visualizerCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }
        }
    }

    // â­ ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¶ãƒ¼çŠ¶æ…‹ã®æ›´æ–° (bodyã‚¯ãƒ©ã‚¹ã®åˆ‡ã‚Šæ›¿ãˆ)
    function updateVisualizerState() {
        const body = document.body;
        visualizerToggle.checked = isVisualizerEnabled;
        
        if (isVisualizerEnabled) {
             body.classList.add('visualizer-mode');
           // Ensure canvas is visible and sized correctly when enabling
           visualizerCanvas.style.display = 'block';
           updateVisualizerCanvasSize();
           // Ensure audio graph/analyser ãŒæ¥ç¶šã•ã‚Œã¦ã„ã‚‹
           try {
               if (!isConnected) connectAudioGraph();
           } catch (e) {
               console.warn('updateVisualizerState: connectAudioGraph failed', e);
           }
        } else {
             body.classList.remove('visualizer-mode');
           visualizerCanvas.style.display = 'none';
        }
    }
    
    function calculateRMS(analyser) {
        const buf = new Uint8Array(analyser.fftSize);
        analyser.getByteTimeDomainData(buf);
        let sum = 0;
        for (let i=0; i<buf.length; i++) {
            const n = (buf[i] - 128) / 128.0;
            sum += n * n;
        }
        return Math.min(100, Math.sqrt(sum / buf.length) * 150); 
    }
    
    function connectAudioGraph() {
        if (!isConnected && playlists.length > 0) {
            try {
                source = audioContext.createMediaElementSource(player);
            } catch (e) {
                console.warn('createMediaElementSource failed (maybe already created):', e);
            }

            if (source) source.connect(gainNode);
            gainNode.connect(splitter);

            // Configure analyserMain if not already
            try {
                analyserMain.fftSize = analyserMain.fftSize || 256;
                analyserMain.smoothingTimeConstant = typeof analyserMain.smoothingTimeConstant === 'number' ? analyserMain.smoothingTimeConstant : 0.6;
                analyserMain.minDecibels = analyserMain.minDecibels || -90;
                analyserMain.maxDecibels = analyserMain.maxDecibels || -10;
            } catch (e) {
                console.warn('Failed to configure analyserMain', e);
            }

            // â­ ãƒ¡ã‚¤ãƒ³ã‚¢ãƒŠãƒ©ã‚¤ã‚¶ãƒ¼ã«æ¥ç¶š
            try { gainNode.connect(analyserMain); } catch (e) { /* ignore duplicate connects */ }

            try { gainNode.connect(audioContext.destination); } catch (e) { console.warn('connect destination failed', e); }
            try { splitter.connect(analyserL, 0); splitter.connect(analyserR, 1); } catch (e) { console.warn('splitter connect failed', e); }
            isConnected = true;
        }
    }
    
    // --- ãƒ¡ãƒ‡ã‚£ã‚¢ã‚»ãƒƒã‚·ãƒ§ãƒ³ API (å¤‰æ›´ãªã—) ---
    function setMediaSession(track) {
        if ('mediaSession' in navigator) {
            navigator.mediaSession.metadata = new MediaMetadata({
                title: track.title,
                artist: track.artist,
                album: track.album || '',
                art: [{ src: track.coverArt, sizes: '250x250', type: 'image/jpeg' }]
            });
            
            navigator.mediaSession.setActionHandler('play', () => handleUserAction(togglePlayPause));
            navigator.mediaSession.setActionHandler('pause', () => handleUserAction(togglePlayPause));
            navigator.mediaSession.setActionHandler('previoustrack', () => handleUserAction(playPrev));
            navigator.mediaSession.setActionHandler('nexttrack', () => handleUserAction(playNext));
        }
    }

    function loadAlbumArt(file) {
        if (file && file.coverArt) coverArt.src = file.coverArt;
        else coverArt.src = DEFAULT_COVER_SRC;
        
        if (file && file.lyrics) lyricsDisplay.textContent = file.lyrics;
        else lyricsDisplay.textContent = "æ­Œè©ãªã—";
        
        if (trackDetailsOverlay.classList.contains('show')) {
            showTrackDetails();
        }
    }

    // Convert jsmediatags picture object to a data URL safely (Blob -> FileReader)
    function pictureToDataUrl(picture) {
        return new Promise((resolve, reject) => {
            try {
                const byteArray = new Uint8Array(picture.data);
                const blob = new Blob([byteArray], { type: picture.format || 'image/jpeg' });
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = (e) => reject(e);
                reader.readAsDataURL(blob);
            } catch (e) {
                reject(e);
            }
        });
    }
    
    function toggleFlip() {
        coverArtContainer.classList.toggle('flipped');
    }
    
    function saveState() {
        localStorage.setItem(PLAYER_STATE_KEY, JSON.stringify({
            currentIndex, 
            isLoop, 
            isShuffle, 
            volume: volumeSlider.value,
            crossfade: CROSSFADE_DURATION,
            visualizer: isVisualizerEnabled, 
            playbackPosition: player.currentTime 
        }));
    }
    
    function loadState() {
        const s = JSON.parse(localStorage.getItem(PLAYER_STATE_KEY));
        if (s) {
            currentIndex = s.currentIndex || 0;
            isLoop = s.isLoop || 'off';
            isShuffle = s.isShuffle || false;
            if (s.volume) {
                volumeSlider.value = s.volume;
                updateVolume(s.volume);
            }
            if (s.crossfade) {
                CROSSFADE_DURATION = s.crossfade;
                crossfadeDurationSlider.value = s.crossfade;
                crossfadeValueDisplay.textContent = s.crossfade.toFixed(1);
            }
            // â­ çŠ¶æ…‹ã‚’ãƒ­ãƒ¼ãƒ‰
            isVisualizerEnabled = s.visualizer || false; 
        }
    }

  </script>
</body>
</html>
